//Create an empty file myPN532_def.h. Add the necessary files in it:
#include "main.h"
....


//In code

static uint32_t rfid_tick = 0;
uint8_t pn532_state = 0;

#define PN532_STATE_SET_RESET		0
#define PN532_STATE_UNSET_RESET		1
#define PN532_STATE_GET_VERSION		2
#define PN532_STATE_SEND_SAM		3
#define PN532_STATE_READ_RFID		4
#define PN532_STATE_READ_WAIT_RFID	5

//difference of two ticks
uint32_t HAL_Tick_Diff(uint32_t to, uint32_t tn)
{
	if (tn >= to) return tn - to;
	else return 0xFFFFFFFF - to + tn;
}

//difference with current HAL_GetTick
uint32_t HAL_Diff(uint32_t t)
{
	return HAL_Tick_Diff(t, HAL_GetTick());
}

void PN532_detect_uid(uint8_t *uid, uint8_t uid_len)
{
#define SECTOR					(0x07)
	uint8_t sec = 0x07;
	uint8_t block_number = (sec * 4 + 3);
	uint8_t key_auth[6] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
	
	PN532_res = PN532_MifareClassicAuthBlock(uid, uid_len, block_number, MIFARE_CMD_AUTH_A, key_auth);
	ulog_fmt("PN532: MifareClassicAuthenticateBlock read_block er = %d block = %d\r\n", PN532_res, block_number);
	if (PN532_res != PN532_ERROR_NONE) return;
	PN532_res = PN532_ReadDataBlock(block_number, block_data);
	ulog_fmt("PN532: ReadDataBlock read_block er = %d block = %d\r\n", PN532_res, block_number);
	if (PN532_res != PN532_ERROR_NONE) return;
	...
}	

void rfid_task(void)
{
	uint8_t PN532_version[4];
	uint8_t PN532_res;
	uint8_t uid[MIFARE_UID_MAX_LENGTH];
	uint8_t uid_len;


	switch (pn532_state)
	{
		case  PN532_STATE_SET_RESET:
		    ulog("PN532: reset\r\n");
		    HAL_GPIO_WritePin(PN532_RST_GPIO_Port, PN532_RST_Pin, GPIO_PIN_RESET);
		    rfid_tick = HAL_GetTick();
		    pn532_state = PN532_STATE_UNSET_RESET;
		    break;
		case  PN532_STATE_UNSET_RESET:
			if (HAL_Diff(rfid_tick) > 500) {
			    HAL_GPIO_WritePin(PN532_RST_GPIO_Port, PN532_RST_Pin, GPIO_PIN_SET);
				rfid_tick = HAL_GetTick();
				pn532_state = PN532_STATE_GET_VERSION;
			}
			break;
		case PN532_STATE_GET_VERSION:
			if (HAL_Diff(rfid_tick) > 1000) {
				PN532_res = PN532_GetFirmVersion(PN532_version);
				if (PN532_res == PN532_ERROR_NONE) {
					ulog_fmt("PN532: found with firmware version: %d.%d\r\n", PN532_version[1], PN532_version[2]);
					pn532_state = PN532_STATE_SEND_SAM;
				} else {
					ulog_fmt("PN532: GetFirmVersion not found error=%d\r\n", PN532_res);
					pn532_state = PN532_STATE_SET_RESET;
				}
			}
			break;
		case PN532_STATE_SEND_SAM:
			PN532_res = PN532_SetSamConfig(0x01, 0x14,  0x01);
			if (PN532_res == PN532_ERROR_NONE) {
				ulog("PN532: SamConfig ok\r\n");
				rfid_tick = HAL_GetTick();
				pn532_state = PN532_STATE_READ_RFID;
			} else {
				ulog_fmt("PN532: SamConfig error=%d\r\n", PN532_res);
				pn532_state = PN532_STATE_SET_RESET;
			}
			break;
		case PN532_STATE_READ_RFID:
			if (HAL_Diff(rfid_tick) > 800) {
				rfid_tick = HAL_GetTick();
				PN532_res = PN532_ReadPassTarget(PN532_MIFARE_ISO14443A, uid, MIFARE_UID_MAX_LENGTH, &uid_len);
				if (PN532_res == PN532_ERROR_NONE) {
					PN532_detect_uid(uid, uid_len);
				} else {
					//ulog_fmt("PN532: not read target error=%d\r\n", PN532_res);
					if (PN532_res != PN532_ERROR_RECV_DATA) pn532_state = PN532_STATE_SET_RESET; 
				}
			}
			break;

	}
}
